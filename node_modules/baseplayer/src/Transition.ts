import * as PIXI from 'pixi.js'
import transitions, { GLTransition } from 'gl-transitions'
import { createUniforms, alignTo, SizeType } from './utils/utils'

interface TransitionOptions {
  width: number
  height: number
  resizeMode: SizeType
}

interface TransitionFilterOptions {
  transitionName?: string
  transitionGLSL?: string
  params?: PIXI.UniformDataMap<any>
}

/**!
 * from gl-transition
 */
const resizeModes: { [_: string]: (r: string) => string } = {
  cover: (r: string) =>
    `.5+(uv-.5)*vec2(min(ratio/${r},1.),min(${r}/ratio,1.))`,
  contain: (r: string) =>
    `.5+(uv-.5)*vec2(max(ratio/${r},1.),max(${r}/ratio,1.))`,
  stretch: () => 'uv',
}

const makeFrag = (transitionGLSL: string, resizeMode: string): string => {
  const r = resizeModes[resizeMode]

  return `
    precision highp float;
    varying vec2 vTextureCoord;
    varying vec2 vFilterCoord;
    uniform sampler2D from, to;
    uniform float progress, width, height, _fromR, _toR;
    uniform vec4 filterArea;

    float ratio = width / height;

    vec4 getFromColor(vec2 uv){
      return texture2D(from,${r('_fromR')});
    }
    vec4 getToColor(vec2 uv){
      return texture2D(to,${r('_toR')});
    }
    ${transitionGLSL}
    void main(){
      gl_FragColor=transition((filterArea.xy * vTextureCoord + filterArea.zw) / vec2(width, height));
    }
  `
}

export default class Transition {
  private _container: PIXI.Sprite
  private _renderTextureFrom: PIXI.RenderTexture
  private _renderTextureTo: PIXI.RenderTexture
  private _from: PIXI.Container | null = null
  private _to: PIXI.Container | null = null
  private _filterOptions: TransitionFilterOptions | null = null
  private _filter: PIXI.Filter<any> | null = null
  private _filters: Array<PIXI.Filter<any>> = []
  // private _resizeType: SizeType

  constructor(
    options: TransitionOptions,
    from: PIXI.Container | null,
    to: PIXI.Container | null,
    filterOptions: TransitionFilterOptions | null,
  ) {
    const renderTextureFrom = PIXI.RenderTexture.create(options.width, options.height)
    const renderTextureTo = PIXI.RenderTexture.create(options.width, options.height)
    const container = new PIXI.Sprite()

    Object.assign(container, options)

    this._container = container
    this._renderTextureFrom = renderTextureFrom
    this._renderTextureTo = renderTextureTo
    this._filterOptions = filterOptions
    // this._resizeType = options.resizeMode || 'contain'

    this.from = from
    this.to = to

    this._updateContainer()
  }

  set from(container: PIXI.Container | null) {
    this._from = container
    // if (container) {
    //   alignTo(container, this._renderTextureFrom, this._resizeType)
    // }
  }

  set to(container: PIXI.Container | null) {
    this._to = container
    // if (container) {
    //   alignTo(container, this._renderTextureTo, this._resizeType)
    // }
  }

  set progress(progress: number) {
    this._filter!.uniforms.progress = progress
  }

  set filters(filters: Array<PIXI.Filter<any>>) {
    this._filters = filters
    this._updateFilters()
  }

  set filterOptions(filterOptions: TransitionFilterOptions) {
    this._filterOptions = filterOptions
    this._updateContainer()
  }

  get container() {
    return this._container
  }

  renderTextures(renderer: PIXI.WebGLRenderer) {
    const { _from, _to } = this

    if (_from) {
      renderer.render(_from, this._renderTextureFrom)
    }

    if (_to) {
      renderer.render(_to, this._renderTextureTo)
    }
  }

  private _createFilter() {
    const { transitionName, params } = this._filterOptions!
    let { transitionGLSL } = this._filterOptions!
    const { container } = this

    const vert = undefined
    let paramsUniforms: PIXI.UniformDataMap<any>

    if (!transitionGLSL) {
      const transition = transitions.find((t: any) => t.name === transitionName)
      if (!transition) return null

      paramsUniforms = createUniforms(transition, params)
      transitionGLSL = transition.glsl
    } else {
      paramsUniforms = params || {}
    }

    const frag = makeFrag(transitionGLSL, 'stretch')

    const uniforms: PIXI.UniformDataMap<any> = {
      progress: {
        type: 'float',
        value: 0,
      },
      width: {
        type: 'float',
        value: container.width,
      },
      height: {
        type: 'float',
        value: container.height,
      },
      _fromR: {
        type: 'float',
        value: 1,
      },
      _toR: {
        type: 'float',
        value: 1,
      },
      from: {
        type: 'sampler2D',
        value: this._renderTextureFrom,
      },
      to: {
        type: 'sampler2D',
        value: this._renderTextureTo,
      },
      ...paramsUniforms,
    }

    return new PIXI.Filter(vert, frag, uniforms)
  }

  private _updateFilters() {
    this.container.filters = [this._filter!, ...this._filters]
  }

  private _updateContainer() {
    const { _filterOptions } = this
    if (!_filterOptions) {
      return
    }

    this._filter = this._createFilter()
    this._updateFilters()
  }
}
