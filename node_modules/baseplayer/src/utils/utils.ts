import { GLTransition } from 'gl-transitions'
import { VideoList, TimelineItem, TransitionItem, Rect } from '../types'
import { Container } from 'pixi.js'

export const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms))

export const createUniforms = (transition: GLTransition, params: any = {}) => {
  const { defaultParams, paramsTypes } = transition
  const uniforms: PIXI.UniformDataMap<any> = {}

  for (const key in paramsTypes) {
    const type = paramsTypes[key]
    let value = params[key]
    if (value == null) value = defaultParams[key]

    uniforms[key] = {
      type,
      value,
    }
  }

  return uniforms
}

export type Size = { width: number, height: number }
export type Bound = Size & { x: number, y: number }
export type SizeType = 'contain' | 'cover' | 'stretch'

export const resizeTo = (
  source: Size,
  target: Size,
  sizeType: SizeType,
): Bound => {
  if (sizeType === 'stretch') {
    return {
      ...target,
      x: 0,
      y: 0,
    }
  }

  const sourceRatio = source.width / source.height
  const targetRatio = target.width / target.height

  // 包含，两头留白
  if (sizeType === 'contain') {
    if (sourceRatio > targetRatio) {
      return {
        width: target.width,
        height: target.width / sourceRatio,
        x: 0,
        y: (target.height - target.width / sourceRatio) / 2,
      }
    } else {
      return {
        width: target.height * sourceRatio,
        height: target.height,
        x: (target.width - target.height * sourceRatio) / 2,
        y: 0,
      }
    }
  }

  // cover fix
  if (sourceRatio > targetRatio) {
    return {
      width: target.height * sourceRatio,
      height: target.height,
      x: (target.width - target.height * sourceRatio) / 2,
      y: 0,
    }
  } else {
    return {
      width: target.width,
      height: target.width / sourceRatio,
      x: 0,
      y: (target.height - target.width / sourceRatio) / 2,
    }
  }
}

export const alignTo = (
  child: Container,
  parent: Size,
  sizeType: SizeType,
  crop?: Rect,
 ) => {
  const cropRect = crop ? {
    x: child.width * crop.x,
    y: child.height * crop.y,
    width: child.width * crop.width,
    height: child.height * crop.height,
  } : {
    x: 0,
    y: 0,
    height: child.height,
    width: child.width,
  }

  const bound = resizeTo({
    width: cropRect.width,
    height: cropRect.height,
  }, {
    width: parent.width,
    height: parent.height,
  }, sizeType)

  child.x = ~~(bound.x - bound.width / cropRect.width * cropRect.x)
  child.y = ~~(bound.y - bound.height / cropRect.height * cropRect.y)
  child.width = ~~(bound.width / cropRect.width * child.width)
  child.height = ~~(bound.height / cropRect.height * child.height)

  if (crop) {
    const mask = new PIXI.Graphics()
    mask.beginFill(0).drawRect(bound.x, bound.y, bound.width, bound.height)
    child.mask = mask
  }
}

/**
 * 处理 sequences，去掉非法的 transition
 * @param sequences
 */
export const normalizeSequences = (sequences: VideoList) => {
  return sequences.filter((item, i) => {
    if (item.type === 'video') return item

    const prev = sequences[i - 1]
    const next = sequences[i + 1]
  })
}

/**
 * 将 sequence 预处理成方便使用的格式
 * TODO 处理首尾转场
 * 如果遇到多个 Transition 相连的情况默认只取最后一个 Transition
 * @param sequences
 */
export const preprocessing = (sequences: VideoList) => {
  const timeline: TimelineItem[] = []

  let lastTransition: TransitionItem | null = null
  let offset = 0

  sequences.forEach(item => {
    if (item.type === 'transition') {
      lastTransition = item
    } else {
      if (lastTransition) {
        timeline.push({
          ref: lastTransition,
          startTime: offset - lastTransition.duration / 2,
          endTime: offset + lastTransition.duration / 2,
        })
      }

      timeline.push({
        ref: item,
        startTime: offset,
        endTime: offset + item.duration,
      })

      offset += item.duration

      lastTransition = null
    }
  })

  return timeline
}

export function addEventListenerOnce(
  target: any,
  eventName: string,
  callback: (e: Event) => void,
) {
  const handler = (e: Event) => {
    callback(e)
    target.removeEventListener(eventName, callback, false)
  }

  target.addEventListener(eventName, handler, false)
}
