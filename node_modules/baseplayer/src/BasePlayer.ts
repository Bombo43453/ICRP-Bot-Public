import * as PIXI from 'pixi.js'
import EE from 'eventemitter3'
import throttle from 'lodash.throttle'
import { VideoList, AudioItem, TimelineItem, PartFilter } from './types'
import BaseObject from './Objects/BaseObject'
import VideoRenderObject from './Objects/VideoRenderObject'
import ImageRenderObject from './Objects/ImageRenderObject'
import { preprocessing } from './utils/utils'
import TransitionRenderObject from './Objects/TransitionRenderObject'
import TextureManager from './TextureManager'
import Ticker from './utils/Ticker'
import AudioObject from './Objects/AudioObject'
import DelogoFilter from './filters/delogo/'

export interface VideoData {
  mainline: VideoList
  audios: AudioItem[]
}

export interface BasePlayerOptions {
  width: number
  height: number
  canvas: HTMLCanvasElement
  data: VideoData
  resolution?: number
  FPS?: number
  preserveDrawingBuffer?: boolean
}

export default class BasePlayer extends EE {
  private _data: VideoData

  private _app!: PIXI.Application

  private _paused = true

  private _waiting = false

  private _destroyed = false

  private _lastDate = 0

  private _currentTime = 0

  private _ticker!: Ticker

  private _objects: BaseObject[] = []

  private _kawaseList: PartFilter[] = []

  private _kawaseFilter?: DelogoFilter

  private timeline!: TimelineItem[]

  public textureManager = new TextureManager(true)

  constructor(private options: BasePlayerOptions) {
    super()

    this._data = options.data
    this._app = this._initPIXIApp()
    this._initRenderObjects()
    this._initTicker()
  }

  /**
   * 获取总时长
   */
  public get duration() {
    const { timeline } = this
    if (!timeline.length) return 0
    return timeline[timeline.length - 1].endTime
  }

  public set kawaseList(kawaseList: PartFilter[]) {
    this._kawaseList = kawaseList
    this._render()
  }

  /**
   * 初始化 PIXI Application
   */
  private _initPIXIApp(): PIXI.Application {
    const { options } = this

    const app = new PIXI.Application({
      width: options.width,
      height: options.height,
      resolution: options.resolution || 1,
      view: options.canvas,
      /**
       * 阻止 app 自动渲染，在需要渲染时手动调用 app.render()
       * 减少不必要的 CPU 开销
       */
      autoStart: false,
      preserveDrawingBuffer: options.preserveDrawingBuffer,
    })

    const kawaseFilter = new DelogoFilter()
    app.stage.filters = [kawaseFilter]
    this._kawaseFilter = kawaseFilter

    return app
  }

  /**
   * 初始化 Objects
   */
  private _initRenderObjects() {
    const { _data: data, textureManager } = this
    this._objects.forEach(object => object.destroy())
    this._removeLoadingEvents()

    const { mainline, audios = [] } = data

    const timeline = preprocessing(mainline)

    const mainlineObjects: BaseObject[] = []

    textureManager.startGC()

    timeline.forEach((item, index) => {
      const { ref } = item

      if (ref.type === 'video') {
        mainlineObjects[index] = new VideoRenderObject({
          id: ref.id,
          src: ref.src,
          app: this._app!,
          parent: this._app!.stage,
          player: this,
          startTime: item.startTime,
          duration: ref.duration,
          startPlayTime: ref.seek,
          filter: ref.filter,
          mute: ref.mute,
          crop: ref.crop,
        })
      }

      if (ref.type === 'image') {
        mainlineObjects[index] = new ImageRenderObject({
          id: ref.id,
          src: ref.src,
          app: this._app!,
          parent: this._app!.stage,
          player: this,
          startTime: item.startTime,
          duration: ref.duration,
          filter: ref.filter,
          crop: ref.crop,
        })
      }
    })

    timeline.forEach((item, index) => {
      const { ref } = item

      if (ref.type === 'transition') {
        mainlineObjects[index] = new TransitionRenderObject({
          from: mainlineObjects[index - 1] as any,
          to: mainlineObjects[index + 1] as any,
          duration: ref.duration,
          app: this._app!,
          parent: this._app!.stage,
          player: this,
          startTime: item.startTime,
          transitionGLSL: ref.glsl!,
        })
      }
    })

    const audioObjects = audios.map(audio => {
      return new AudioObject({
        player: this,
        startTime: audio.startTime,
        duration: audio.duration,
        src: audio.src,
        fade: audio.fade,
      })
    })

    this.timeline = timeline

    this._objects = mainlineObjects.concat(audioObjects)
    this._addLoadingEvents()

    textureManager.finishGC()
  }

  /**
   * 获取当前时间
   */
  public get currentTime() {
    return this._currentTime
  }

  /**
   * 设置当前时间
   * @param time
   */
  public set currentTime(time: number) {
    if (this._waiting) {
      // 强制改变时间后，需要去掉 waiting 状态
      this._waiting = false
      this.emit('canplay')
    }

    this._currentTime = time
    this._lastDate = Date.now()
    this._render(true)
  }

  public play() {
    if (!this._paused) return

    if (this.currentTime === this.duration) {
      this.currentTime = 0
    }

    this._paused = false
    this._resumeTicker()
  }

  public pause() {
    if (this._paused) return

    this._paused = true
    this._pauseTicker()
    this._render(true)

    this.emit('pause')
  }

  public get paused() {
    return this._paused
  }

  /**
   * 更新播放器数据
   * @param data
   */
  public setData(data: VideoData) {
    this._data = data
    this._initRenderObjects()
  }

  /**
   * 重设尺寸
   * 因为 Video/Image/Transition 均有尺寸对齐的操作，重新处理不太方便
   * 所以简单粗暴地重新 init 元素
   * @param size
   */
  public resize(width: number, height: number) {
    this._app.renderer.resize(width, height)
    this._initRenderObjects()
  }

  /**
   * 兼容 TYPO
   */
  public destory() {
    this.destroy()
  }

  /**
   * 销毁播放器
   */
  public destroy() {
    if (this._destroyed) return

    this._removeLoadingEvents()
    this._ticker.stop()
    this._app.destroy()
    this._objects.forEach(object => object.destroy())
    this.textureManager.destroy()
    this._destroyed = true
  }
  /**
   * 截图 => Base64
   */
  public snapshot() {
    // extract 的效果有一些问题，先不用
    // const image = this._app.renderer.plugins.extract.image(this._app.stage)

    if (!this.options.preserveDrawingBuffer) {
      console.warn('截图需要开启 preserveDrawingBuffer 参数')
    }

    return this._app.view.toDataURL()
  }

  private _tick(time: number) {
    this._currentTime = time

    this.emit('timeupdate', time)

    if (time === this.duration) {
      this._paused = true
      this._pauseTicker()

      this.emit('end')
      this.emit('pause')
    }
  }

  /**
   * 初始化 Ticker
   */
  private _initTicker() {
    this._ticker = new Ticker(date => {
      if (!this._waiting) {
        this._tick(Math.min(
          (date - this._lastDate) / 1000 + this._currentTime,
          this.duration,
        ))
      }

      this._lastDate = date
      this._render()
    }, {
      FPS: this.options.FPS || 25,
    })
  }

  private _pauseTicker() {
    this._ticker.stop()
  }

  private _resumeTicker() {
    this._lastDate = Date.now()
    this._ticker.start()
  }

  _onWaiting = (videoObject: VideoRenderObject) => {
    const activeTransition = this._findTransitionAt(this._currentTime)

    if (!activeTransition && videoObject.active) {
      this._waiting = true
      this.emit('waiting')
    }
  }

  /**
   * TODO 应该根据视频元素的播放时间重新设置播放器时间
   */
  _onCanplay = (videoObject: VideoRenderObject) => {
    if (videoObject.active) {
      this._waiting = false
      this._lastDate = Date.now()

      /**
       * 暂停状态下 ticker 是停止状态的，当视频加载完成时需要手动执行一下 render
       */
      if (this._paused) {
        this._render()
      }

      this.emit('canplay')
    }
  }

  /**
   * 判断某个时间点是否有转场进行中
   * @param time
   */
  private _findTransitionAt(time: number) {
    return this.timeline.find(item => {
      return (
        item.startTime <= time &&
        item.endTime > time &&
        item.ref.type === 'transition'
      )
    })
  }

  private _addLoadingEvents() {
    this._objects.forEach(object => {
      if (object instanceof VideoRenderObject) {
        object.on('waiting', this._onWaiting)
        object.on('seeking', this._onWaiting)
        object.on('canplay', this._onCanplay)
      }
    })
  }

  private _removeLoadingEvents() {
    this._objects.forEach(object => {
      if (object instanceof VideoRenderObject) {
        object.off('waiting', this._onWaiting)
        object.off('seeking', this._onWaiting)
        object.off('canplay', this._onCanplay)
      }
    })
  }

  /**
   * 预加载下 N 个视频，并将这些视频的 currentTime 设为开始播放的时间
   * 由于没测量具体性能损耗，暂时将 _preloadNext 函数节流到 3s 每次
   * @param currentIndex 当前的 object 在 _objects 中的下标
   */
  private _preloadNextFrom = throttle((currentIndex: number) => {
    const { _objects } = this
    // 预加载后面三个
    let n = 3

    for (let i = currentIndex + 1; i < _objects.length; i++) {
      const object = _objects[i]

      if (object instanceof VideoRenderObject) {
        object.preloadAndSeekStart()

        if (--n === 0) {
          return
        }
      }
    }
  }, 800)

  private _renderKawaseBlurFilter() {
    const { _currentTime, _kawaseList, _kawaseFilter } = this
    if (!_kawaseFilter) return

    const currentKawaseList = _kawaseList.filter(item => (
      item.startTime <= _currentTime &&
      item.startTime + item.duration > _currentTime
    ))

    _kawaseFilter.areas = currentKawaseList
    _kawaseFilter.enabled = currentKawaseList.length > 0
  }

  private _render(force = false) {
    const { _currentTime } = this

    // 当前播放的视频/图片 ID
    let lastCurrentIndex = -1

    this._objects.forEach((object, index) => {
      object.sync(_currentTime, force)
      if (
        object.active &&
        (
          object instanceof ImageRenderObject ||
          object instanceof VideoRenderObject
        )
      ) {
        lastCurrentIndex = index
      }
    })

    if (lastCurrentIndex !== -1) {
      this._preloadNextFrom(lastCurrentIndex)
    }

    this._renderKawaseBlurFilter()

    this._app.render()
  }
}
