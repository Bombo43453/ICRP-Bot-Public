// tslint:disable
/**
 * 修改自 pixi-filters 的 kawase-blur
 * @see https://github.com/pixijs/pixi-filters/blob/master/filters/kawase-blur/src/KawaseBlurFilter.js
 * 原滤镜是将整个画面进行高斯模糊，修改后支持多个（最高 5 个）局部区域的高斯模糊。
 * @author zhubo
 */

import * as PIXI from 'pixi.js'
import { vertex } from '../../utils/shaders'

const MAX_NUM = 5

const fragment = `
varying vec2 vTextureCoord;
uniform sampler2D uSampler;
uniform vec4 filterArea;
uniform int areas[${MAX_NUM * 5}];

uniform vec2 uOffset;

vec2 mapCoord(vec2 coord)
{
  coord *= filterArea.xy;
  coord += filterArea.zw;

  return coord;
}

vec2 unmapCoord(vec2 coord)
{
  coord -= filterArea.zw;
  coord /= filterArea.xy;

  return coord;
}

vec4 kawase()
{
  vec4 color = vec4(0.0);

  // Sample top left pixel
  color += texture2D(uSampler, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y));

  // Sample top right pixel
  color += texture2D(uSampler, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y));

  // Sample bottom right pixel
  color += texture2D(uSampler, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y));

  // Sample bottom left pixel
  color += texture2D(uSampler, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y));

  // Average
  color *= 0.25;

  return color;
}

void main(void)
{
  vec2 pixel = mapCoord(vTextureCoord);
  int x = int(pixel.x);
  int y = int(pixel.y);

  bool inAreas = false;

  for (int i = 0; i < ${MAX_NUM}; i++) {
    if (areas[i * 5 + 0] == 0) break;

    inAreas = inAreas || (
      x > areas[i * 5 + 1] &&
      y > areas[i * 5 + 2] &&
      x < areas[i * 5 + 3] + areas[i * 5 + 1] &&
      y < areas[i * 5 + 4] + areas[i * 5 + 2]
    );
  }

  if (inAreas)
  {
    gl_FragColor = kawase();
  }
  else
  {
    gl_FragColor = texture2D(uSampler, vTextureCoord);
  }
}
`


/**
 * uniform areas 数据格式：
 * [
 *   YES, x, y, width, height,
 *   YES, x, y, width, height,
 * ]
 * 当 YES 为 0 时，忽略掉后面的内容。
 */

/**
 * A much faster blur than Gaussian blur, but more complicated to use.<br>
 * ![original](../tools/screenshots/dist/original.png)![filter](../tools/screenshots/dist/kawase-blur.png)
 *
 * @see https://software.intel.com/en-us/blogs/2014/07/15/an-investigation-of-fast-real-time-gpu-based-image-blur-algorithms
 * @class
 * @extends PIXI.Filter
 * @memberof PIXI.filters
 * @param {number|number[]} [blur=4] - The blur of the filter. Should be greater than `0`. If
 *    value is an Array, setting kernels.
 * @param {number} [quality=3] - The quality of the filter. Should be an integer greater than `1`.
 */
export default class KawaseBlurFilter extends PIXI.Filter<{
  uOffset: Float32Array
  areas: Uint16Array
}> {
  private _kernels: number[]
  private _quality!: number
  private _blur!: number
  private _pixelSize: PIXI.Point

  constructor(blur = 4, quality = 3) {
    super(vertex, fragment);
    this.uniforms.uOffset = new Float32Array(2);
    this.uniforms.areas = new Uint16Array([0]);

    this._pixelSize = new PIXI.Point(1, 1);
    this._kernels = null as any;

    // if `blur` is array , as kernels
    if (Array.isArray(blur)) {
      this.kernels = blur;
    }
    else {
      this._blur = blur;
      this.quality = quality;
    }
  }

  /**
   * Overrides apply
   * @private
   */
  apply(filterManager: PIXI.FilterManager, input: any, output: any, clear: any) {
    const uvX = this.pixelSize.x / input.size.width;
    const uvY = this.pixelSize.y / input.size.height;
    let offset;

    if (this._quality === 1 || this._blur === 0) {
      offset = this._kernels[0] + 0.5;
      this.uniforms.uOffset[0] = offset * uvX;
      this.uniforms.uOffset[1] = offset * uvY;
      filterManager.applyFilter(this, input, output, clear);
    }
    else {
      const renderTarget = filterManager.getRenderTarget(true);

      let source = input;
      let target = renderTarget;
      let tmp;

      const last = this._quality - 1;

      for (let i = 0; i < last; i++) {
        offset = this._kernels[i] + 0.5;
        this.uniforms.uOffset[0] = offset * uvX;
        this.uniforms.uOffset[1] = offset * uvY;
        filterManager.applyFilter(this, source, target, true);

        tmp = source;
        source = target;
        target = tmp;
      }
      offset = this._kernels[last] + 0.5;
      this.uniforms.uOffset[0] = offset * uvX;
      this.uniforms.uOffset[1] = offset * uvY;
      filterManager.applyFilter(this, source, output, clear);

      filterManager.returnRenderTarget(renderTarget);
    }
  }

  /**
   * Auto generate kernels by blur & quality
   * @private
   */
  _generateKernels() {
    const blur = this._blur;
    const quality = this._quality;
    const kernels = [blur];

    if (blur > 0) {
      let k = blur;
      const step = blur / quality;

      for (let i = 1; i < quality; i++) {
        k -= step;
        kernels.push(k);
      }
    }

    this._kernels = kernels;
  }

  /**
   * The kernel size of the blur filter, for advanced usage.
   *
   * @member {number[]}
   * @default [0]
   */
  get kernels() {
    return this._kernels;
  }
  set kernels(value) {
    if (Array.isArray(value) && value.length > 0) {
      this._kernels = value;
      this._quality = value.length;
      this._blur = Math.max.apply(Math, value);
    }
    else {
      // if value is invalid , set default value
      this._kernels = [0];
      this._quality = 1;
    }
  }

  /**
   * Sets the pixel size of the filter. Large size is blurrier. For advanced usage.
   *
   * @member {PIXI.Point|number[]}
   * @default [1, 1]
   */
  set pixelSize(value: PIXI.Point) {
    if (typeof value === 'number') {
      this._pixelSize.x = value;
      this._pixelSize.y = value;
    }
    else if (Array.isArray(value)) {
      this._pixelSize.x = value[0];
      this._pixelSize.y = value[1];
    }
    else if (value instanceof PIXI.Point) {
      this._pixelSize.x = value.x;
      this._pixelSize.y = value.y;
    }
    else {
      // if value is invalid , set default value
      this._pixelSize.x = 1;
      this._pixelSize.y = 1;
    }
  }

  get pixelSize() {
    return this._pixelSize;
  }

  /**
   * The quality of the filter, integer greater than `1`.
   *
   * @member {number}
   * @default 3
   */
  get quality() {
    return this._quality;
  }
  set quality(value) {
    this._quality = Math.max(1, Math.round(value));
    this._generateKernels();
  }

  /**
   * The amount of blur, value greater than `0`.
   *
   * @member {number}
   * @default 4
   */
  get blur() {
    return this._blur;
  }
  set blur(value) {
    this._blur = value;
    this._generateKernels();
  }

  set areas(areas: Array<{x: number, y: number, width: number, height: number}>) {
    const intArray = new Uint16Array(MAX_NUM * 5);
    areas.forEach((area, index) => {
      intArray[index * 5] = 1
      intArray[index * 5 + 1] = area.x
      intArray[index * 5 + 2] = area.y
      intArray[index * 5 + 3] = area.width
      intArray[index * 5 + 4] = area.height
    })

    if (areas.length * 5 < intArray.length) {
      // 终结
      intArray[areas.length * 5] = 0
    }

    this.uniforms.areas = intArray
  }
}
