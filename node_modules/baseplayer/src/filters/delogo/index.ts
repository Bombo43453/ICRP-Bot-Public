import { Filter } from 'pixi.js'
import { vertex } from '../../utils/shaders'

const MAX_NUM = 5

const fragment = `
varying vec2 vTextureCoord;
uniform sampler2D uSampler;
uniform vec4 filterArea;
uniform int areas[${MAX_NUM * 5}];

vec2 mapCoord(vec2 coord)
{
  coord *= filterArea.xy;
  coord += filterArea.zw;

  return coord;
}

vec2 unmapCoord(vec2 coord)
{
  coord -= filterArea.zw;
  coord /= filterArea.xy;

  return coord;
}

// 仿 FFmpeg/libavfilter/vf_delogo.c，有出入
vec4 kawase(vec2 pixel, vec4 area)
{
  vec4 colorTop = texture2D(uSampler, unmapCoord(vec2(pixel.x, area.y)));
  vec4 colorBottom = texture2D(uSampler, unmapCoord(vec2(pixel.x, area.y + area.w)));
  vec4 colorLeft = texture2D(uSampler, unmapCoord(vec2(area.x, pixel.y)));
  vec4 colorRight = texture2D(uSampler, unmapCoord(vec2(area.x + area.z, pixel.y)));

  float weightTop = (pixel.x - area.x) * ((area.x + area.z) - pixel.x) * (area.y + area.w - pixel.y);
  float weightBottom = (pixel.x - area.x) * ((area.x + area.z) - pixel.x) * (pixel.y - area.y);
  float weightLeft = ((area.x + area.z) - pixel.x) * (pixel.y - area.y) * (area.y + area.w - pixel.y);
  float weightRight = (pixel.x - area.x) * (pixel.y - area.y) * (area.y + area.w - pixel.y);

  vec4 color = (
    colorTop * weightTop +
    colorBottom * weightBottom +
    colorLeft * weightLeft +
    colorRight * weightRight
  ) / (
    weightTop + weightBottom + weightLeft + weightRight
  );

  return color;
}

void main(void)
{
  vec2 pixel = mapCoord(vTextureCoord);
  int x = int(pixel.x);
  int y = int(pixel.y);

  bool inAreas = false;
  vec4 area = vec4(0);

  for (int i = 0; i < ${MAX_NUM}; i++) {
    if (areas[i * 5 + 0] == 0) break;
    int ix = areas[i * 5 + 1];
    int iy = areas[i * 5 + 2];
    int iwidth = areas[i * 5 + 3];
    int iheight = areas[i * 5 + 4];

    if (x > ix && y > iy && x < ix + iwidth && y < iy + iheight) {
      inAreas = true;
      area = vec4(ix, iy, iwidth, iheight);
    }
  }

  if (inAreas)
  {
    gl_FragColor = kawase(pixel, area);
  }
  else
  {
    gl_FragColor = texture2D(uSampler, vTextureCoord);
  }
}
`

export default class PixelateFilter extends Filter<{
  areas: Uint16Array
}> {

  constructor() {
    super(vertex, fragment)
    this.uniforms.areas = new Uint16Array([0])
  }

  set areas(areas: Array<{ x: number, y: number, width: number, height: number }>) {
    const intArray = new Uint16Array(MAX_NUM * 5)
    areas.forEach((area, index) => {
      intArray[index * 5] = 1
      intArray[index * 5 + 1] = area.x
      intArray[index * 5 + 2] = area.y
      intArray[index * 5 + 3] = area.width
      intArray[index * 5 + 4] = area.height
    })

    if (areas.length * 5 < intArray.length) {
      // 终结
      intArray[areas.length * 5] = 0
    }

    this.uniforms.areas = intArray
  }
}
