import BaseRenderObject, { BaseRenderConfig } from './BaseRenderObject'
import { alignTo } from '../utils/utils'

interface VideoRenderConfig extends BaseRenderConfig {
  src: string
  startPlayTime: number,
  mute?: boolean
}

export default class VideoRenderObject extends BaseRenderObject<VideoRenderConfig> {
  sprite!: PIXI.Sprite
  container!: PIXI.Container
  video!: HTMLVideoElement

  private preload(startPlayTime = 0) {
    const { video } = this
    if (video.preload === 'none') {
      video.preload = 'auto'
      if (video.__hls__) {
        video.__hls__.startLoad(startPlayTime)
      } else {
        video.load()
      }
    }
  }

  /**
   * 预加载视频
   * 1. 视频文件 HTTP 预加载
   * 视频在最初被创建到时候，其 preload 都为 none，当预加载后，preload 就变成了 auto
   * 以此区分视频是否被预加载过
   * 2. 视频画面预 seek
   * 将视频画面 seek 到首帧（startPlayTime）
   * 以免切换到当前视频时，尤其是通过转场进来时画面不对。
   */
  preloadAndSeekStart() {
    const { startPlayTime } = this.config

    this.preload(startPlayTime)
    if (!this.active) {
      this.seekToTime(0)
    }
  }

  /**
   * 传入播放器绝对时间，返回 video 的相对时间
   * @param time
   */
  timeToVideoTime(time: number) {
    const { startTime, startPlayTime } = this.config
    return time - startTime + startPlayTime + 0.0001
  }

  /**
   * 和 timeToVideoTime 相反
   * @param videoTime
   */
  videoTimeToTime(videoTime: number) {
    const { startTime, startPlayTime } = this.config
    return videoTime + startTime - startPlayTime
  }

  /**
   * seek 视频到一个相对于视频的 cutStartTime 的时间
   * @param time
   */
  seekToTime(time: number) {
    const { video } = this
    const targetVideoTime = time + this.config.startPlayTime
    if (Math.abs(targetVideoTime - video.currentTime) > 0.01) {
      video.currentTime = targetVideoTime + 0.0001
    }
  }

  /**
   * 播放中的缓冲等待会触发 waiting
   * @param e
   */
  _onWaiting(e: Event) {
    this.emit('waiting', this)
  }

  /**
   * 暂停时的缓冲等待会触发 seeking
   * @param e
   */
  _onSeeking(e: Event) {
    this.emit('seeking', this)
  }

  _onCanPlay(e: Event) {
    this.emit('canplay', this)

    if (this.active) {
      this._tryForceUpdateVideoTimeIfNeed()
    }
  }

  /**
   * 由于某些原因视频播放进度会小于 player 时间，需要进行矫正
   */
  _tryForceUpdateVideoTimeIfNeed() {
    const { currentTime, duration } = this.video
    const expectedCurrentTime = this.timeToVideoTime(this.config.player.currentTime)

    if (
      expectedCurrentTime - currentTime > 0.1 &&
      expectedCurrentTime > 0 &&
      expectedCurrentTime < duration
     ) {
      this.video.currentTime = expectedCurrentTime
    }
  }

  _bindEvents() {
    this._onSeeking = this._onSeeking.bind(this)
    this._onWaiting = this._onWaiting.bind(this)
    this._onCanPlay = this._onCanPlay.bind(this)

    this.video.addEventListener('seeking', this._onSeeking, false)
    this.video.addEventListener('waiting', this._onWaiting, false)
    this.video.addEventListener('canplay', this._onCanPlay, false)
  }

  _unbindEvents() {
    this.video.removeEventListener('seeking', this._onSeeking, false)
    this.video.removeEventListener('waiting', this._onWaiting, false)
    this.video.removeEventListener('canplay', this._onCanPlay, false)
  }

  protected get _filterTargetContainer() {
    return this.sprite
  }

  protected _onload() {
    alignTo(this.sprite, this.config.app.screen, 'contain', this.config.crop)

    // super._onload 中设置 uniform.height
    super._onload()
  }

  _createRenderContainer() {
    const { src, player, mute } = this.config

    const texture = player.textureManager.createTexture(src, this.config.id || null, 'video')

    const sprite = new PIXI.Sprite(texture)
    const baseTexture = sprite.texture.baseTexture as PIXI.VideoBaseTexture
    const video = baseTexture.source
    baseTexture.autoPlay = false
    const container = new PIXI.Container()
    container.addChild(sprite)

    this.sprite = sprite
    this.container = container
    this.video = video
    this.video.muted = !!mute

    this._bindEvents()

    if (!sprite.texture.baseTexture.hasLoaded) {
      sprite.texture.baseTexture.once('loaded', () => this._onload())
    } else {
      this._onload()
    }

    return container
  }

  _render(offsetTime: number, force: boolean) {
    super._render(offsetTime, force)

    const { player, startPlayTime } = this.config

    this.sprite.texture.update()

    if (force) {
      this.seekToTime(offsetTime)

      this.preload(startPlayTime + offsetTime)
    }

    if (player.paused && !this.video.paused) {
      this.video.pause()
    }

    if (!player.paused && this.video.paused) {
      this.video.play()
    }
  }

  _onInactive() {
    super._onInactive()
    this.video.pause()
  }

  _destroy() {
    super._destroy()
    this._unbindEvents()
  }
}
