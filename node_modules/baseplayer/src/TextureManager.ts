import Hls from 'hls.js'
import { addEventListenerOnce } from './utils/utils'

class PLoader extends Hls.DefaultConfig.loader {
  addEndlist(data: string) {
    if (!/#EXT-X-ENDLIST/.test(data)) {
      return data + '\n#EXT-X-ENDLIST\n'
    } else {
      return data
    }
  }

  load(
    context: Hls.LoaderContext,
    config: Hls.LoaderConfig,
    callbacks: Hls.LoaderCallbacks,
  ) {
    const loader = this

    if (context.type === 'manifest') {
      const onSuccess = callbacks.onSuccess
      callbacks.onSuccess = (response, stats, context) => {
        response.data = loader.addEndlist(response.data as string)
        onSuccess(response, stats, context)
      }
    }

    super.load(context, config, callbacks)
  }
}
export default class TextureManager {
  private _textureCache?: Map<string | number, {
    using: boolean
    texture: PIXI.Texture
  }>

  constructor(private hasTextureCache: boolean) {
    if (hasTextureCache) {
      this._textureCache = new Map()
    }
  }

  /**
   * 播放器需要 setData 前，首先需要调用这个函数，将所有缓存的 texture 标为未使用。
   * 播放器调用 setData 过程中，会调用 manager.createTexture，这个过程中被用到的素材会被标为使用中。
   * 播放器调用 setData 结束后，调用 finishGC，将未使用的 Texture 清理干净。
   */
  startGC() {
    const { _textureCache } = this
    if (_textureCache) {
      for (const item of _textureCache.values()) {
        item.using = false
      }
    }
  }

  finishGC() {
    const { _textureCache } = this
    if (_textureCache) {
      for (const [key, value] of _textureCache) {
        if (!value.using) {
          _textureCache.delete(key)
          this.destroyTexture(value.texture)
        }
      }
    }
  }

  private destroyTexture(texture: PIXI.Texture) {
    const { source } = texture.baseTexture
    if (source instanceof HTMLVideoElement) {
      source.pause()
      source.src = ''
      source.load()

      const { __hls__ } = source
      if (__hls__) {
        __hls__.destroy()
      }
    }
  }

  createTexture(
    src: string,
    id: any,
    type: 'image' | 'video',
  ) {
    const { _textureCache } = this
    const hitTarget = _textureCache && id && _textureCache.get(id)

    if (hitTarget) {
      hitTarget.using = true
    }

    let texture = hitTarget && hitTarget.texture

    if (!texture) {
      if (type === 'video') {
        const video = document.createElement('video')
        // 视频不要预加载，否则几十上百个视频会导致 Network 阻塞
        video.preload = 'none'
        const baseTexture = new PIXI.BaseTexture(video)

        // HLS 适配
        if (/\.m3u8(\?.*)?/.test(src)) {
          if (Hls.isSupported()) {
            const hls = new Hls({
              autoStartLoad: false,
              pLoader: PLoader,
              maxFragLookUpTolerance: 0,
            })
            hls.attachMedia(video)
            hls.on(Hls.Events.MEDIA_ATTACHED, () => {
              hls.loadSource(src)
            })
            video.__hls__ = hls
          } else {
            // Throw error?
            console.error('Hls is not supported')
          }
        } else {
          video.src = src
          video.crossOrigin = 'anonymous'
        }

        addEventListenerOnce(video, 'canplay', e => {
          baseTexture.width = video.videoWidth
          baseTexture.height = video.videoHeight
          baseTexture.hasLoaded = true
          baseTexture.emit('loaded', baseTexture)
        })

        texture = new PIXI.Texture(baseTexture)
      } else {
        texture = PIXI.Texture.from(src)
      }

      if (_textureCache && id) {
        _textureCache.set(id, {
          using: true,
          texture,
        })
      }
    }

    return texture
  }

  destroy() {
    const { _textureCache } = this

    if (_textureCache) {
      for (const value of _textureCache.values()) {
        this.destroyTexture(value.texture)
      }
      _textureCache.clear()
      this._textureCache = undefined
    }
  }
}
