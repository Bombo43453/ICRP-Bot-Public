// tslint:disable
export default [
  // 0
  `
    const vec2 center = vec2(0.5, 0.5);
    const float angle = 1.57;
    const float scale = 2.49;
    const vec2 tSize = vec2(256.0, 256.0);

    float pattern(vec2 uv) {
          float s = sin( angle ), c = cos( angle );
          vec2 tex = uv * tSize - center;
          vec2 point = vec2( c * tex.x - s * tex.y, s * tex.x + c * tex.y ) * scale;
          return ( sin( point.x ) * sin( point.y ) ) * 4.0;
    }

    vec4 transition(vec2 uv)
    {
          vec4 color = texture2D( to, uv );
          float average = ( color.r + color.g + color.b ) / 3.0;
          return vec4( vec3( average * 10.0 - 5.0 + pattern(uv) ), color.a );
    }
  `,
  // 1
  `
    const float TWO_PI = 6.283185307179586;

    /*------可调参数------- */
    // 双色调参数，深、浅两种颜色（rgb分量均归一化）
    vec3 colLight = vec3(231.0, 48.0, 94.0)/255.0;  // 对应颜色#e7305e
    vec3 colDark = vec3(46.0, 48.0, 96.0)/255.0;    // 对应颜色#2e3060

    // 切片运动参数
    const float slices = 12.0;  // 切片数目
    const float offset = 0.04;  // 切片运动的偏移量
    const float speedV = -2.0;  // 切片运动速度，正负号调整运动方向（向上或向下）

    float steppedVal(float v, float steps)
    {
      return floor(v*steps)/steps;
    }

    float random1d(float n)
    {
      return fract(sin(n) * 43758.5453);
    }

    float noise1d(float p)
    {
      float fl = floor(p);
      float fc = fract(p);
      return mix(random1d(fl), random1d(fl + 1.0), fc);
    }

    // 设置切片，调整纹理坐标，通过水平方向上相邻图片段的不同移动方向实现切片运动效果
    vec2 makeslices(vec2 uv)
    {
      float n = noise1d(uv.y * slices + time * 0.1 * speedV * 3.0);
      float ns = steppedVal(fract(n),slices) + 2.0;
      float nsr = random1d(ns);
      vec2 uvn = uv;
      uvn.x += nsr * sin(time * 0.1 * TWO_PI + nsr * 20.0) * offset;
      return uvn;
    }

    float luma(vec3 color)
    {
    return dot(color, vec3(0.299, 0.587, 0.114));
    }

    // 双色调效果
    vec3 duotone(sampler2D tex, vec2 texcoord)
    {
      vec3 col =  texture2D(tex, texcoord).rgb;
      col = clamp(col,0.0,1.0);
      return mix(colDark,colLight, luma(col));
    }

    vec4 transition(vec2 uv)
    {
      vec4 outs;
      // 切片运动，调整纹理坐标
      vec2 p = makeslices(uv);
      // 双色调处理
      vec3 duocol = duotone(to, p);

      return vec4(duocol, 1.0);
    }
  `,
  // 2
  `
    float TWO_PI= 6.283185307179586;
    float amount=.1;
    float rotateSpeed =1.0;
    //双阈值检测
    float threshold(in float thr1, in float thr2 , in float val)
    {
        if (val < thr1) {return 0.0;}
        if (val > thr2) {return 1.0;}
        return val;
    }

    // 三个通道的颜色差取平均
    float diff(in vec4 pix1, in vec4 pix2) {
        return (
                abs(pix1.r - pix2.r) +
                abs(pix1.g - pix2.g) +
                abs(pix1.b - pix2.b)
                ) / 3.0;
    }

    //转动
    vec2 rotate2D(vec2 position, float theta)
    {
    mat2 m = mat2( cos(theta), -sin(theta), sin(theta), cos(theta) );
    return m * position;
    }


    float edge(in sampler2D tex, in vec2 coords, in vec2 renderSize,in float d,in vec2 offset)
    {
        float dx = d / renderSize.x;//dx=0.001
        float dy = d / renderSize.y;//dy=0.001
        vec4 pix[9];
        vec2 pos[9];
        vec2 newpos[9];

        vec2 dOffset=vec2(0.,0.);//offset的倒数,边缘位置偏移量
        if(offset.x!=0. && offset.y !=0.)
        {
        dOffset.x=1.0/offset.x;
        dOffset.y=1.0/offset.y;
        }

        pos[0]= vec2( -1.0 * dx, -1.0 * dy)+dOffset;
        pos[1]= vec2( -1.0 * dx, 0.0 * dy)+dOffset;
        pos[2]= vec2( -1.0 * dx, 1.0 * dy)+dOffset;
        pos[3]= vec2( 0.0 * dx, -1.0 * dy)+dOffset;
        pos[4]= vec2( 0.0 * dx, 0.0 * dy)+dOffset;
        pos[5]= vec2( 0.0 * dx, 1.0 * dy)+dOffset;
        pos[6]= vec2( 1.0 * dx, -1.0 * dy)+dOffset;
        pos[7]= vec2( 1.0 * dx, 0.0 * dy)+dOffset;
        pos[8]= vec2( 1.0 * dx, 1.0 * dy)+dOffset;

        for(int i=0;i<9;i++)
        {
            newpos[i] = coords+rotate2D(pos[i],0.2*time*rotateSpeed*TWO_PI);
            pix[i] = texture2D(tex, newpos[i]);
        }


        float delta = (diff(pix[1],pix[7])+
                      diff(pix[5],pix[3]) +
                      diff(pix[0],pix[8])+
                      diff(pix[2],pix[6])
                      )/4.;
        return threshold(0.25,0.4,clamp(3.0*delta,0.0,1.0));

    }
    vec4 transition(vec2 uv)
    {
        vec3 rgb=texture2D(to,uv).rgb;
        float RedResult = edge(to,uv,vec2(1000.,1000.),1.0,vec2(0.,0.));
        vec3 RedCol= mix(vec3(0.),vec3(1.,.0,.0),RedResult);

        float GreenResult = edge(to,uv,vec2(1000.,1000.),1.0,vec2(50.,50.));
        vec3 GreenCol= mix(vec3(0.),vec3(.0,1.,.0),GreenResult);

        float BlueResult = edge(to,uv,vec2(1000.,1000.),1.0,vec2(100.,100.));
        vec3 BlueCol= mix(vec3(0.),vec3(.0,.0,1.),BlueResult);


        vec3 resultColor=vec3(0.0,0.0,0.0);
        //三张图合成，浮点数比较大小
        if(RedResult-1.0<0.1 && RedResult -1.0>-0.1)
            resultColor=vec3(1.0,0.0,0.0);
        else if(GreenResult-1.0<0.1 && GreenResult-1.0>-0.1)
            resultColor=vec3(0.0,1.0,0.0);
        else if(BlueResult-1.0<0.1 && BlueResult-1.0>-0.1)
            resultColor=vec3(0.0,0.0,1.0);


        return vec4(resultColor,1.0);

    }
  `,
  // 3
  `
    const float pixelsX = 0.005;
    const float pixelsY = 0.02;

    // posterize
    const float levels = 10.0;

    const float hue = 1.1;
    const float saturation = 0.0;


    vec4 transition(vec2 uv) {
        vec2 normCoord = 2.0 * uv - 1.0;
        float r = length(normCoord);
        float phi = atan(normCoord.y, normCoord.x);
        r = r - mod(r, pixelsX) + 0.03;
        phi = phi - mod(phi, pixelsY);
        normCoord.x = r * cos(phi);
        normCoord.y = r * sin(phi);
        vec2 textureCoordinateToUse = normCoord / 2.0 + 0.5;
        vec4 polarPixel = texture2D(to, textureCoordinateToUse );
        //return polarPixel;

        // effect 2: posterize
        vec3 posterize = floor((polarPixel.rgb * levels) + vec3(0.5)) / levels;
        //return vec4(posterize, 1.0);

        // effect 3: hue/saturation
        vec4 hueRgb = vec4(posterize, 1.0);
        float angle = (hue + 0.1*time) * 3.14159265;
        float s = sin(angle), c = cos(angle);
        vec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;
        float len = length(hueRgb.rgb);

        hueRgb.rgb = vec3(
            dot(hueRgb.rgb, weights.xyz),
            dot(hueRgb.rgb, weights.zxy),
            dot(hueRgb.rgb, weights.yzx)
        );
        float average = (hueRgb.r + hueRgb.g + hueRgb.b) / 3.0;
        if (saturation > 0.0) {
            hueRgb.rgb += (average - hueRgb.rgb) * (1.0 - 1.0 / (1.001 - saturation));
        } else {
            hueRgb.rgb += (average - hueRgb.rgb) * (-saturation);
        }
        return hueRgb;
    }
  `,
  // 4
  `
    float amount=.5;
    float offset=.5;

    vec3 rainbow2( in float t )
    {
    vec3 d = vec3(0.0,0.33,0.67);
        //return d;
    return  0.5+0.5*cos( 6.28318*(t+d) );//保证不会产生负数
    }

    vec4 transition(vec2 uv)
    {
    vec2 p = uv;
    vec3 origCol = texture2D(to, p).rgb;
    vec2 off = texture2D(to,p).rg-.5;//rg分量处理，降低明度，增加对比度
    p += off * offset;//根据坐标产生不同颜色，使用加法而不用乘法整张图变化更大

    //10控制变化速度,.5控制渐变带的大小，越大越锯齿严重,越小越不明显
    //vec3 rb = rainbow2((p.x + p.y + progress * 1.5) * .5);
    vec3 rb = rainbow2((p.x + p.y + 0.2*time * 1.5) * .5);

    //彩色贴图与原图对半叠加
    vec3 col = mix(origCol,rb,amount);
    return vec4(col,1.0);
    }
  `,
  // 5
  `
    float smooth_pulse(float x)
    {
        float result = smoothstep(.0,.5,x)-smoothstep(.5,1.,x);
        return result;
    }

    vec4 transition(vec2 p) {
        vec2 block = floor(p.xy / vec2(16));
        vec2 uv_noise = block / vec2(64);
        uv_noise += floor(vec2(0.2*time) * vec2(400.0, .0)) / vec2(12);//分子频率，分母振动幅度，水平方向振动
        vec2 dist = 0.1*time > 0.0 ? (fract(uv_noise) - .0) * 0.05 *(1.0 -0.1*time) : vec2(0.0);
        vec2 red = p + dist * 0.1;
        vec2 green = p + dist * .5;//绿色移位幅度
        vec2 blue = p + dist * .1;

        vec2 red2 = p - dist * 0.1;
        vec2 green2= p - dist * 0.5;
        vec2 blue2 = p - dist * 0.1;

        float colorx;
        float colory;
        float colorz;

        colorx=mix(texture2D(to, vec2(red.x, red.y)),texture2D(to, vec2(red.x,  red.y)),0.1*time).r;
        colory=mix(texture2D(to, vec2(green.x, green.y)),texture2D(to, vec2(green.x, green.y)),0.1*time).g;
        colorz=mix(texture2D(to, vec2(blue.x,  blue.y)),texture2D(to, vec2(blue.x, blue.y)),0.1*time).b;


        return vec4(colorx,colory,colorz,1.0);
    }
  `,
  // 6
  `
    vec4 transition(vec2 uv)
    {
        vec2 p = mapCoord(uv);
        if (p.x > width / 2.) {
            p.x = width - p.x;
        }

        return texture2D (to, unmapCoord(p));
    }
  `,
  // 7
  `
    const float dots = 120.;
    const float size = 0.44;
    const float blur = 0.397;

    // wobble
    const float strength = 0.02;
    const float wobbleSize = 6.0;
    const float TWO_PI = 6.283185307179586;

    vec2 wobble(vec2 uv)
    {
        vec2 p = -1.0 + 2.0 * uv;
        // progress 需要换成 time
        float pos = 0.1*time * TWO_PI + length(p * wobbleSize);
        vec2 wobCoord = uv + strength * vec2(cos(pos), sin(pos));
        return wobCoord;
        // vec4 wobble = texture2D(to, wobCoord);
        // return wobble;
    }

    vec4 transition(vec2 uv)
    {
        float dotSize = 1.0/dots;
        vec2 samplePos = uv - mod(uv, dotSize) + 0.5 * dotSize;
        float distanceFromSamplePoint = distance(samplePos, uv);

        vec2 wob = wobble(samplePos);
        vec4 col = texture2D(to, wob);
        vec4 dotMatix = mix(col, vec4(0.0), smoothstep(dotSize * size, dotSize *(size + blur), distanceFromSamplePoint));
        return dotMatix;
    }
  `,
  // 8
  `
    float zoom_quickness=2.; //越大放大速度越小
    float move_quickness=1.; //越大移动速度越小
    float nQuick = clamp(zoom_quickness,0.0,1.0);
    float speed=1.0;

    vec2 zoom(vec2 uv, float amount)
    {
        return 0.3 + ((uv - 0.3) * (1.0 - amount));//固定点为中心
    }

    vec2 translation(vec2 uv,float amount)
    {
        return uv+vec2(0.,amount);//往上移动是+，即其坐标转换为等于其下方的某个点，向下是y轴正方向
    }

    vec4 getColor(vec2 uv)
    {
        return texture2D(to, vec2(uv.x, uv.y));
    }

    vec4 transition (vec2 uv)
    {
        vec2 zoompos = uv;

        float i_time = time;
        zoompos = zoom(uv,smoothstep(0.0,nQuick, 0.1 * i_time/speed));

        if (i_time > 5.0) { // 业务目前限定最长放大 5s
            i_time = 5.0;
            zoompos = zoom(uv,smoothstep(0.0,nQuick, 0.1 * i_time/speed));
        } else {
            zoompos = translation(zoompos, smoothstep(0.0, move_quickness, smoothstep(0.0, 1.0, (0.1 * i_time - 0.5) / speed)));
        }
        return getColor(zoompos);
    }
  `
]
